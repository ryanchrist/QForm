% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QFGaussBounds.R
\name{QFGaussBounds}
\alias{QFGaussBounds}
\title{Bounds on the CDF of a Quadratic Form in Gaussians}
\usage{
QFGaussBounds(
  cdf,
  f = "identity",
  max.abs.eta,
  sum.eta,
  sum.etasq,
  sum.eta.deltasq = 0,
  sum.etasq.deltasq = 0,
  include.saddlepoint = FALSE
)
}
\arguments{
\item{cdf}{function; the cdf of \eqn{T_f} returned by \code{QForm::QForm}}

\item{f}{character or QFormFunction object; the function \eqn{f} for the \eqn{Q_f} of interest.}

\item{max.abs.eta}{vector; element-wise upper bound on the absolute value of the \eqn{\eta_i} in \eqn{R_f} (see Details)}

\item{sum.eta}{vector; element-wise sum of the \eqn{\eta_i} in \eqn{R_f} (see Details)}

\item{sum.etasq}{vector; element-wise sum of the \eqn{\eta^2_i} in \eqn{R_f} (see Details)}

\item{sum.eta.deltasq}{vector; element-wise sum of the \eqn{\eta_i \delta^2_i} in \eqn{R_f} (see Details)}

\item{sum.etasq.deltasq}{vector; element-wise sum of the \eqn{\eta^2_i \delta^2_i} in \eqn{R_f} (see Details)}
}
\value{
A vectorized function which evaluates upper and lower bounds on the CDF of \eqn{Q_f}.
}
\description{
Returns a function for calculating upper and lower bounds on the CDF for random variables \eqn{Q_f = T_f + R_f} where \deqn{T_f = \sum\limits_{i \in \mathcal{T}} f\left(\eta_i \right) \left(Z_i + \delta_i)^2,}{T_f = \Sigma_{i \in T} f (\eta_i) (Z_i + \delta_i)^2,}
\deqn{R_f = \sum\limits_{i \in \mathcal{R}} f\left(\eta_i \right) \left(Z_i + \delta_i)^2,}{R_f = \Sigma_{i \in R} f (\eta_i) (Z_i + \delta_i)^2,} where \eqn{Z_i \sim N(0,1)}{Z_i ~ N(0,1)}, and only the CDF of \eqn{T_f} is known.
}
\details{
If \code{max.abs.eta} < \code{.Machine$double.eps}, then the contribution of \eqn{R_f} to \eqn{Q_f} is ignored for numerical stability and the function returned is simply wrapper for the provided CDF of \eqn{T_f}.  If this is not desired, a user may want to consider rescaling \eqn{Q_f} to avoid this behavior.
Currently only \eqn{f = "identity"} is supported, but future versions will allow one to select \eqn{f} from a list or specify their own function with its corresponding bounds through a QFormFunction object.

The returned bounds function takes a vector of observed values \code{q} at which to calculate bounds as it's main argument. If \code{q} is not known exactly, but only a lower bound \code{ql} and an upper bound \code{qu} are known, then those may provided instead of \code{q} and the returned bounds on the CDF will be valid for a \code{q} in \code{[ql,qu]}.  If \code{q} is provided, \code{ql} and \code{qu} are ignored.
The returned bounds function itself returns a matrix with four columns: \code{c("lower.bound","upper.bound","one.minus.lower.bound","one.minus.upper.bound")}.  The first and second columns are lower and upper bounds on the CDF at \code{q} respectively; the third and fourth columns are equal to one minus the first two columns but calculated separately by the function internally in order to maintain numerical precision in the upper tail.  Thus, it is strongly recommneded that users interested in upper tail p-values use the third and fourth columns rather than the first and second.

The returned bounds function can also take a parallel version of sapply from a given R parallelization package via the optional argument \code{parallel.sapply}.  This can substantially speed up computation for long \code{q}.  See Example below and \code{\link{QFGauss}} for more details.

\code{QFGaussBounds} cannot currently calculate bounds for a cdf returned by \code{QFGauss} that has a missing tail.  See \code{\link{QFGauss}} for more details.
}
\examples{

f.eta <- c(-12, -7, 5, 7, -9, 10, 8)
delta2 <- c(2, 10, -4, 3, 8, -5, -12)^2

cdf <- QFGauss(f.eta, delta2)

bounds <- QFGaussBounds(cdf = cdf, f = "identity",
                        max.abs.eta = 10, sum.eta = 5, sum.etasq = 200)

\dontrun{
# Evaluate the bounds at a set of points
xx <- seq(-1e3, 1e3, len = 6)
## This may take 5 - 10 secs.
system.time(y <- bounds(xx))

x <- seq(-1e3, 1e3, len = 1e3)
plot(x, cdf(x), type = "l", ylab = expression(CDF),xlab=expression(T[f]), main=expression(Bounds~on~CDF~of~T[f])) # CDF
points(xx, y[,1], col = "blue")
points(xx, y[,2], col = "red")

# Generate diagnostic plots for bounds (currently TestQFGaussBounds only works for cases where the QFGauss produeced CDF has all df = 1.)
TestQFGaussBounds(QFGauss(c(1,5,-4,-3,10),c(2,-1,4,-5,5)^2),2)

# The function returned by QFGaussBounds can be accelerated by passing it a parallel version of sapply
# In this example we use only 2 parallel workers but more may be added
require(future.apply); plan(tweak(multiprocess,workers = 2))
system.time(y <- bounds(xx, parallel.sapply = future_sapply))
}

}
\seealso{
\code{\link{QFGauss}}, \code{\link{TestQFGaussBounds}}
}
